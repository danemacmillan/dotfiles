## .functions

# TODO:
# Create a function to generate archives based on desired output filename.
# E.g.: archive archivename.tgz dirname/
# and the function will know to generate a tar gzip file.
#
# tar cvzf media.tgz --totals media/
#
#


## 
# Loop through all subdirectories and run the given command."
loop() {
	if [[ -z $1 ]]; then
		echo -e "Loop through all subdirectories of the current directory and run"
		echo -e "the given commands.\n"
		echo -e "Example usage:\n"
		echo '  loop "touch notes.txt"'
		echo '  loop "git pull" "git push"'
		echo ""
		return
	fi
	
	# Fancy up the message.
	SYMBOL1="->"
	SYMBOL2="+"
	if [[ $OS == 'osx' ]]; then
		SYMBOL1="🌀 "
		SYMBOL2="⚡️"
	fi

	for subdirectory in ./*; do
		echo -e "\n\x1B[0m\x1B[48;5;234m$SYMBOL1 \x1B[97;1mRunning commands in \x1B[90m$subdirectory\x1B[0m"
		for argument in "$@"; do
			echo -e "   $SYMBOL2 \x1B[93m$argument\x1B[0m\x1B[38;5;237m"
			(cd "$subdirectory" && $argument 2>&1 | sed -e 's/^/        /')
		done
	done

	echo -e ""
}

##
# Merge all canonical branches from current directory.
choochoo() {
	echo -e "Running a train on this bitch. HIYOOOOO."
	git checkout develop && git pull && git checkout stage && git pull && git merge develop && git push && git checkout master && git pull && git merge stage && git push && git checkout develop
	echo -e "All canonical branches merged up to master."
}

##
# Get current OS version and other information.
v() {
	case $OS in
		osx)
			system_profiler SPSoftwareDataType
			;;
		# Note, at this point nix is technically CentOS. Update .bashrc to
		# represent more OSes.
		nix)
			echo -e "Operating System:\n"
			echo -e "    `cat /etc/redhat-release`\n"
			;;
	esac

	echo -e "Kernel & Architecture:\n"
	echo -e "    `uname -r -v -p`\n"
}


## 
# Usage: extract <file>
# Description: extracts archived files / mounts disk images
# Note: .dmg/hdiutil is Mac OS X-specific.
# Credit: https://github.com/holman/dotfiles
extract () {
	if [ -f $1 ]; then
		case $1 in
			*.tar.bz2)  tar -jxvf $1 ;;
			*.tar.gz)   tar -zxvf $1 ;;
			*.bz2)      bunzip2 $1 ;;
			*.dmg)      hdiutil mount $1 ;;
			*.gz)       gunzip $1 ;;
			*.tar)      tar -xvf $1 ;;
			*.tbz2)     tar -jxvf $1 ;;
			*.tgz)      tar -zxvf $1 ;;
			*.zip)      unzip $1 ;;
			*.ZIP)      unzip $1 ;;
			*.pax)      cat $1 | pax -r ;;
			*.pax.Z)    uncompress $1 --stdout | pax -r ;;
			*.Z)        uncompress $1 ;;
			*)          echo "'$1' cannot be extracted/mounted via extract()" ;;
		esac
	else
		echo "'$1' is not a valid file"
	fi
}


##
# Determine size of a file or total size of a directory.
# Credit: https://github.com/mathiasbynens/dotfiles
function fs() {
	if du -b /dev/null > /dev/null 2>&1; then
		local arg=-sbh;
	else
		local arg=-sh;
	fi

	if [[ -n "$@" ]]; then
		du $arg -- "$@";
	else
		du $arg .[^.]* *;
	fi
}

##
# Get total directory and file count.
function total() {
	CHECKDIR=.
	if [[ -n "$1" ]]; then
		CHECKDIR="$1"
	fi
	
	# Directory listings include "." and ".."
	DIRECTORY_PADDING=1
	
	DIRECTORIES="`find $CHECKDIR -maxdepth 1 -type d | wc -l`"
	DIRECTORIES_WITH_LINKS="`find $CHECKDIR -follow -maxdepth 1 -type d | wc -l`"
	DIRECTORIES_LINKS="`expr $DIRECTORIES_WITH_LINKS - $DIRECTORIES`"
	FILES="`find $CHECKDIR -maxdepth 1 -type f | wc -l`"
	FILES_WITH_LINKS="`find $CHECKDIR -follow -maxdepth 1 -type f | wc -l`"
	FILES_LINKS="`expr $FILES_WITH_LINKS - $FILES`"

	echo "Directories: `expr $DIRECTORIES_WITH_LINKS - $DIRECTORY_PADDING` (`expr $DIRECTORIES_LINKS`)"
	echo "Files: $FILES_WITH_LINKS ($FILES_LINKS)"
}

##
# Auto-generate new SSH keys with option to provide passphrase
# Note: if you want characters like "!" in your passphrase, run like this:
# newsshkey 'Long passphrase!!!! with spaces and niceties!'
# If you just have regular characters, quoting is unnecessary.
function newsshkey() {
	KEY_STRENGTH="4096"
	KEY_NAME=~/.ssh/id_rsa_${KEY_STRENGTH}_`date +%Y-%m-%d-%H%M%S`
	
	KEY_PASSPHRASE=""
	if [[ -n "$1" ]]; then
		KEY_PASSPHRASE="$1"
	fi

	ssh-keygen -b $KEY_STRENGTH -f $KEY_NAME -C $KEY_NAME -N "$KEY_PASSPHRASE"
	
	echo -e "\nPassphrase:" \"$KEY_PASSPHRASE\"
	echo -e "\nProvide this public key to your devop if required:\n"
	cat $KEY_NAME.pub

	# Remove passphrase from appearing in bash history, if provided.
	# Source: http://thoughtsbyclayg.blogspot.ca/2008/02/how-to-delete-last-command-from-bash.html
	if [[ -n "$1" ]]; then
		history -d $((HISTCMD-2)) && history -d $((HISTCMD-1))
	fi
}
